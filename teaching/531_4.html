<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Optimality Theory: rankings, GEN, CON, and EVAL</title>
	<meta name="author" content="Brian W. Smith"/>
	<meta name="date" content="9/15/2019"/>
	<link type="text/css" rel="stylesheet" href="bws.css"/>
</head>
<body>

<!-- Standard header. Change title in metadata -->

<p><a href="531_guide.html">USC Graduate Phonology</a> ✳︎ Fall 2019 ✳︎ Smith</p>

<hr />

<div class="title">

<p>Optimality Theory: rankings, GEN, CON, and EVAL</p>

</div>

<div class="TOC">

<ul>
<li><a href="#optimalitytheory">Optimality Theory</a></li>
<li><a href="#aninput→outputderivationinot">An /input/→[output] derivation in OT</a></li>
<li><a href="#coreproposalsofot">Core proposals of OT</a></li>
<li><a href="#thearchitectureofanotgrammar">The architecture of an OT grammar</a></li>
<li><a href="#thelexicon">The lexicon</a></li>
<li><a href="#gen:thegeneratorfunction">GEN: the generator function</a></li>
<li><a href="#con:theconstraintset">CON: the constraint set</a></li>
<li><a href="#eval:theevaluatorfunction">EVAL: the evaluator function</a></li>
<li><a href="#anexample">An example</a></li>
<li><a href="#theottableau">The OT tableau</a></li>
<li><a href="#practicetableau">Practice tableau</a></li>
<li><a href="#recapofmajorideas">Recap of major ideas</a></li>
</ul>
</div>

<hr />

<blockquote>
<p>I say I listen to all voices but mine’s the final decision. [&#8230;] I hear the voices and I read the front page and I know the speculation but I’m the decider and I decide what is best.&quot;</p>

<p>George W. Bush</p>
</blockquote>

<!-- Content starts below -->

<h1 id="optimalitytheory">Optimality Theory</h1>

<ul>
<li>We&#8217;re going to be discussing what&#8217;s sometimes called <em>Classic</em> Optimality Theory, consisting of:

<ul>
<li>Optimality Theory (Prince &amp; Smolensky 1993)</li>
<li>Correspondence Theory (McCarthy &amp; Prince 1995), which revised faithfulness constraints.</li>
<li>Generalized Alignment (McCarthy &amp; Prince 1993), which introduced alignment constraints.</li>
</ul></li>
<li>Keep in mind that nearly every imagineable revision to OT assumptions has been pursued at some point in the past 20+ years, and much of the research in OT has been devoted to answering the question &#8220;What are the constraints?&#8221;</li>
</ul>

<h1 id="aninput→outputderivationinot">An /input/→[output] derivation in OT</h1>

<ul>
<li>Start with an input.</li>
<li>Generate a set of <strong>candidates</strong> (possible outputs).</li>
<li>Pick the <strong>optimal</strong> candidate, the candidate that is best according to the <strong>constraint ranking</strong> for the language.</li>
<li>The optimal candidate is the output of the grammar.</li>
</ul>

<h1 id="coreproposalsofot">Core proposals of OT</h1>

<ul>
<li>The grammar generates mappings via a <strong>strict ranking</strong> of <strong>violable constraints</strong>.

<ul>
<li>Constraints penalize marked structures in SRs, e.g. &#8220;Don&#8217;t end a word with a voiced obstruent,&#8221; or deviating from URs, e.g. &#8220;Don&#8217;t devoice.&#8221;</li>
<li>Constraints are in a <strong>strict ranking</strong> (strict total order).

<ul>
<li>For every pair of contraints, A and B, there is an ordering between them. Either A ranks above B, or B ranks above A.</li>
<li>Ranking is transitive. If A ranks above B, and B ranks above C, then A ranks above C.</li>
</ul></li>
<li>When two constraints have conflicting requirements, satisfaction of the higher ranked constraint takes priority (no exceptions!).

<ul>
<li>What happens if the constraint &#8220;Don&#8217;t end a word with a voiced obstruent&#8221; takes priority over &#8220;Don&#8217;t devoice&#8221;?</li>
<li>What happens if the constraint &#8220;Don&#8217;t devoice&#8221; takes priority over &#8220;Don&#8217;t end a word with a voiced obstruent&#8221;?</li>
</ul></li>
<li>If constraint A is ranked above constraint B, we say that A <strong>dominates</strong> B, and can write this with a much-greater-than symbol: A <strong>≫</strong> B.</li>
</ul></li>
<li>Constraint interaction aims to capture <em>all</em> aspects of the phonological system in a language.

<ul>
<li>The ranking of constraints accounts for the segmental inventory of a language, its phonotactics, and its alternations.</li>
<li>A particular language has the same ranking of constraints for all parts of the language.</li>
<li>Important to note: although each language has the same ranking of constraints for every part of the language, we usually cannot discover a single strict total order of constraints.

<ul>
<li>It&#8217;s nearly always the case that a set of mappings can be generated by many different strict total orders of constraints.</li>
<li>When we construct a ranking for a particular language, we describe only the rankings that are <em>necessary</em> to generate the attested mappings, narrowing down the space of possibilities.</li>
</ul></li>
</ul></li>
<li>The ranking of constraints is the <em>only</em> way languages differ from one another (except for vocabulary).

<ul>
<li>Constraints are universal.</li>
<li>The mechanism of candidate generation is universal.</li>
<li>The mechanism for choosing the optimal candidate is universal.</li>
<li>There are no language-particular restrictions on URs.</li>
</ul></li>
<li>Constraint re-ranking captures cross-linguistic variation and typology.

<ul>
<li>Every ranking of constraints is predicted to be a possible language.</li>
<li><strong>Factorial typology</strong>: There are n! orderings of constraints (n = number of constraints), and thus n! possible rankings.

<ul>
<li>n! (n factorial) is the product of all positive integers less than or equal to n.</li>
<li>5! = 5 * 4 * 3 * 2 * 1 = 120</li>
<li>Although there are 120 rankings of 5 constraints, chances are that many of these rankings will generate the same input-output mappings, so there are likely fewer than 120 different sets of input-output mappings.</li>
</ul></li>
</ul></li>
</ul>

<h1 id="thearchitectureofanotgrammar">The architecture of an OT grammar</h1>

<ul>
<li>The lexicon: contains a list of URs, and other unpredictable information</li>
<li><strong>GEN</strong>: the function that generates candidates</li>
<li><strong>CON</strong>: the set of universal constraints</li>
<li>A language-particular ranking of constraints from CON: sometimes written as <strong>ℋ</strong> for hierarchy</li>
<li><strong>EVAL</strong>: the function that selects the optimal candidate(s) from the candidate set, based on the ranking of constraints</li>
<li>A full derivation looks like this:

<ul>
<li>1. Start with an input: /ab/</li>
<li>2. Generate the candidate set: GEN(/ab/)</li>
<li>3. Pick the output: EVAL(input, candidates, ℋ)</li>
<li>This can be written as a single line: EVAL(/ab/, GEN(/ab/), ℋ)</li>
</ul></li>
<li>Since ranking is the only language-particular part of the grammar, GEN, CON, and EVAL are the same for every language.</li>
</ul>

<h1 id="thelexicon">The lexicon</h1>

<ul>
<li>The lexicon contains all contrastive properties of morphemes, including phonological, morphological, syntactic, and semantic properties.</li>
<li>There are no language-particular restrictions on the phonological forms of URs.

<ul>
<li>Constraints evaluate SRs or similarity between URs and SRs.</li>
</ul></li>
<li>The lack of restrictions on URs is a property called <strong>Richness of the Base</strong>, and means the set of logically possible URs is the same for every language.</li>
</ul>

<h1 id="gen:thegeneratorfunction">GEN: the generator function</h1>

<ul>
<li>The function that generates a set of candidate outputs from the input.</li>
<li>One way to think of it: apply all possible operations to the input, any number of times (deletion, insertion, feature changing, maybe changing order)

<ul>
<li>The resulting set of candidates is infinite (even if we assume a finite alphabet of symbols).</li>
<li>The candidate set always contains a <strong>faithful candidate</strong>, an output candidate which is identical to the input.</li>
</ul></li>
<li>Candidates have an input portion (UR) and an output portion (SR), and nothing else. There are no intermediate forms as there are for SPE-style rules.</li>
<li>GEN(/ab/) = {[ab], [a], [b], [ba], [ ], [ta], [at], [ae], [diii], &#8230;}</li>
<li>The property that GEN can generate any conceivable output candidate for some input is called <strong>Freedom of Analysis</strong>.

<ul>
<li>That&#8217;s not to say GEN can generate <em>anything</em>. Candidates must still be composed of elements from the universal vocabularies of linguistic representation, e.g. segments, features, syllables.</li>
<li>Whatever limits there <em>are</em> on GEN, those limits are universal.</li>
</ul></li>
</ul>

<h1 id="con:theconstraintset">CON: the constraint set</h1>

<ul>
<li>There are two kinds of constraints:

<ul>
<li><strong>Markedness constraints</strong> impose requirements on output candidates.

<ul>
<li>*[+voice] = don&#8217;t have a voiced segment</li>
<li><span style="font-variant:small-caps;">Agree</span>(voice) = adjacent segments should agree in voicing</li>
</ul></li>
<li><strong>Faithfulness constraints</strong> militate against deviating from the input.

<ul>
<li><span style="font-variant:small-caps;">Dep</span> = don&#8217;t epenthesize</li>
<li><span style="font-variant:small-caps;">Max</span> = don&#8217;t delete</li>
<li><span style="font-variant:small-caps;">Ident</span>([feature]) = don&#8217;t change the value of [feature]</li>
</ul></li>
</ul></li>
<li>A markedness constraint can be treated as a function from a candidate output to a positive integer (the number of <strong>violations</strong>).

<ul>
<li>Violations are a penalty score: fewer violations is better.</li>
<li>Constraints only assign violations. They never directly reward candidates.</li>
<li>*CC([bak]) = 0</li>
<li>*CC([tikpad]) = 1</li>
</ul></li>
<li>A faithfulness constraint can be treated as a function from an input-output pair to a positive integer (the number of violations):

<ul>
<li><span style="font-variant:small-caps;">Max</span>(/bak/, [ba]) = 1</li>
<li><span style="font-variant:small-caps;">Max</span>(/bak/, [bak]) = 0</li>
</ul></li>
<li>The best way to write constraints is to describe the function explicitly, starting with &#8220;Assign one violation for every…&#8221;, and give it a descriptive name (often written in small caps and/or with a *).</li>
<li>Here are examples of constraints that have been proposed in the OT literature:

<ul>
<li>*[+voice] = Assign one violation for every segment in the output that has the feature [+voice].</li>
<li>*<span style="font-variant:small-caps;">Struc</span> = Assign one violation for every segment in the output.</li>
<li><span style="font-variant:small-caps;">Agree</span>(voice) = Assign one violation for every sequence of two segments in the output which do not have identical value for the [voice] feature.</li>
<li>*CC = assign one violation for every sequence of two consonants in the output..</li>
<li><span style="font-variant:small-caps;">Max</span> = Assign one violation for every segment in the input that isn&#8217;t in the output.</li>
<li><span style="font-variant:small-caps;">Dep-V</span> = Assign one violation for every vowel in the output that isn&#8217;t in the input.</li>
</ul></li>
<li>Let&#8217;s assess the violations of *CC:

<ul>
<li>*CC([bakta]) = ?</li>
<li>*CC([abtako]) = ?</li>
<li>*CC([abitaki]) = ?</li>
<li>*CC([brabtakpi]) = ?</li>
</ul></li>
</ul>

<h1 id="eval:theevaluatorfunction">EVAL: the evaluator function</h1>

<ul>
<li>The function that selects the winner from the set of candidates.

<ul>
<li>Function arguments: input, set of output candidates, ranking of constraints  </li>
<li>Output of function: subset of the candidates that are optimal</li>
<li>EVAL(/input/, GEN(/input/), ranking) = {[output]}  </li>
</ul></li>
<li>We can think of many ways that EVAL could work&#8230;

<ul>
<li><strong>Strict domination</strong> is the mechanism used in standard OT for adjudicating harmony disagreements among constraints.</li>
<li>Satisfaction of a higher-ranked constraint takes <em>absolute priority</em> over the satisfaction of all lower-ranked constraints.</li>
<li>A possibly helpful analogy: you can think of the constraint ranking as a hierarchy of authoritarian autocrats, each of whom defers to his superior and doesn&#8217;t care about the opinions of his underlings.</li>
</ul></li>
<li>To find just the winners, if you have n constraints&#8230;

<ul>
<li>Find the candidates that tie for being &#8220;best&#8221; (fewest violations) on the top-ranked constraint C<sub>1</sub>; discard the rest.

<ul>
<li>Because of strict domination, none of the lower-ranked constraints matter &#8211; just the constraint currently under consideration.</li>
</ul></li>
<li>Of the remaining candidates, find those the next constraint, C<sub>2</sub>, deems best; discard the rest.</li>
<li>Repeat for C<sub>3</sub>, &#8230;, C<sub>n</sub>, stopping if you have only one candidate left.</li>
<li>As a slogan: &#8220;Take the best, ignore the rest.&#8221;<a href="#fn:1" id="fnref:1" title="see footnote" class="footnote"><sup>1</sup></a></li>
<li>Whatever candidates are still left at the end are tied for being the winner.</li>
<li>If you have enough constraints, there is normally just one winner.</li>
</ul></li>
<li>Given how EVAL works, what a constraint <em>must</em> be able to do is identify the best candidate(s) out of a set of candidates.

<ul>
<li>Treating constraints as functions that return positive integers simplifies this calculation.</li>
<li>But we <em>could</em> in theory have a constraint like <span style="font-variant:small-caps;">AlphabeticalOrder</span>, which favors candidates that are earlier in alphabetical order. Since this constraint is able to pick the best candidates out of a set, it can get the job done.</li>
</ul></li>
</ul>

<h1 id="anexample">An example</h1>

<ul>
<li>What does output does the grammar genarate for:

<ul>
<li>Input: /ab/</li>
<li>Ranking: *ab ≫ <span style="font-variant:small-caps;">Max</span> ≫ *a ≫ *b</li>
</ul></li>
<li>First, generate a candidate set: GEN(/ab/) = {[ab], [a], [b], []}</li>
<li>Pick the best candidate with EVAL:

<ul>
<li>EVAL(/ab/, {[ab], [a], [b], []}, ranking)</li>
<li>For the remaining candidates, {[ab], [a], [b], []}</br>check the first constraint: <strong>*ab</strong> ≫ <span style="font-variant:small-caps;">Max</span> ≫ *a ≫ *b

<ul>
<li>*ab: assign one violation for every [a] followed by [b]</li>
<li>*ab([ab]) = 1</li>
<li>*ab([a]) = 0</li>
<li>*ab([b]) = 0</li>
<li>*ab([]) = 0</li>
<li>Take the candidates that have the fewest violations and discard the rest.</li>
<li>Remaining candidates: {[a], [b], []}</li>
<li>Remaining constraints to check: <span style="font-variant:small-caps;">Max</span> ≫ *a ≫ *b</li>
<li>Stop if either:

<ul>
<li>There is a single remaining candidate. (Nope)</li>
<li>There are no more constraints to check. (Nope)</li>
</ul></li>
</ul></li>
<li>For the remaining candidates, {[a], [b], []},</br>check the next constraint: *ab ≫ <strong><span style="font-variant:small-caps;">Max</span></strong> ≫ *a ≫ *b

<ul>
<li><span style="font-variant:small-caps;">Max</span>: assign one violation for every segment in the input that isn&#8217;t in the output.</li>
<li><span style="font-variant:small-caps;">Max</span>(/ab/, [a]) = 1</li>
<li><span style="font-variant:small-caps;">Max</span>(/ab/, [b]) = 1</li>
<li><span style="font-variant:small-caps;">Max</span>(/ab/, []) = 2</li>
<li>Take the best, ignore the rest.</li>
<li>Remaining candidates: {[a], [b]}</li>
<li>Remaining constraints to check: *a ≫ *b</li>
<li>Stop if either:

<ul>
<li>There is a single remaining candidate. (Nope)</li>
<li>There are no more constraints to check. (Nope)</li>
</ul></li>
</ul></li>
<li>For the remaining candidates, {[a], [b]},</br>check the next constraint: *ab ≫ <span style="font-variant:small-caps;">Max</span> ≫ <strong>*a</strong> ≫ *b

<ul>
<li>*a: assign one violation for every [a].</li>
<li>*a([a]) = 1</li>
<li>*a([b]) = 0</li>
<li>Take the best, ignore the rest.</li>
<li>Remaining candidates: {[b]}</li>
<li>Remaining constraints to check: *b</li>
<li>Stop if either:

<ul>
<li>There is a single remaining candidate. (Yes! Stop!)</li>
<li>There are no more constraints to check. (Nope)</li>
</ul></li>
</ul></li>
</ul></li>
<li>Output: [b]</li>
<li>If we repeat this for different inputs, we get a set of mappings generated by the ranking.

<ul>
<li>Mappings generated by *ab ≫ <span style="font-variant:small-caps;">Max</span> ≫ *a ≫ *b:

<ul>
<li>/ab/ → [b]</li>
<li>/b/ → [b]</li>
<li>/a/ → [a]</li>
<li>/ba/ → [ba]</li>
<li>etc.</li>
</ul></li>
<li>As mentioned a few times above, different rankings will often produce the same mappings.</li>
</ul></li>
<li>We considered only four candidates from the candidate set of /ab/. Is there a candidate for /ab/ that we didn&#8217;t consider, which could&#8217;ve beaten [b]?</li>
</ul>

<h1 id="theottableau">The OT tableau</h1>

<ul>
<li>The <strong>tableau</strong> (from French, pronounced [ˌtʰæˈblow] in English, plural tableaux [ˌtʰæˈblow] or [ˌtʰæˈblowz]) is a way to illustrate a fragment of this calculation.</li>
<li>Not all candidates can be shown; not all constraints are shown, either.</li>
<li>The tableau is not a full calculation, but rather an illustrative device, like a derivation in rule-based analyses.</li>
<li>This tableau shows a <strong>ranking argument</strong> for *CC ≫ <span style="font-variant:small-caps;">Dep-V</span>.</li>
</ul>

<div class="tableau">

<table>
<caption style="caption-side: bottom;" id="exampleofatableauwithoutshadingorexclamationmarks">Example of a tableau without shading or exclamation marks</caption>
<colgroup>
<col />
<col style="text-align:left;"/>
<col style="text-align:right;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
	<th colspan="3">Candidates  </th>
	<th style="text-align:center;">    <em>*CC</em> </th>
	<th style="text-align:center;"><em>Dep&#8211;V</em> </th>
</tr>
</thead>

<tbody>
<tr>
	<td>/at-ka/ </td>
	<td style="text-align:left;">a. </td>
	<td style="text-align:right;">☞ [atəka]  </td>
	<td style="text-align:center;">  </td>
	<td style="text-align:center;"> ✳︎  </td>
</tr>
<tr>
	<td>   </td>
	<td style="text-align:left;">b. </td>
	<td style="text-align:right;">[atka]   </td>
	<td style="text-align:center;">✳︎  </td>
	<td style="text-align:center;">  </td>
</tr>
</tbody>
</table>

</div>

<ul>
<li>Important parts of the tableau:

<ul>
<li>/input/ &#8211; sometimes this is in the upper lefthand corner</li>
<li>[output] candidates &#8211; which are usually lettered for reference</li>
<li>pointing finger &#8211; indicates winner

<ul>
<li>An equivalent rightward pointing arrow is sometimes used instead.</li>
<li>The name of the pointing finger in typography is the <a href="https://en.wikipedia.org/wiki/Index_(typography)">&#8220;index&#8221; or &#8220;manicule.&#8221;</a></li>
</ul></li>
<li>constraints &#8211; the columns are in descending order of rank: higher-ranking constraints are on the left</li>
<li>asterisks &#8211; one for each constraint violation

<ul>
<li>Numbers are now commonly used instead</li>
</ul></li>
</ul></li>
<li>Sometimes there are different types of lines between constraints:

<ul>
<li>solid line between constraints &#8211; represents a <strong>crucial ranking</strong></li>
<li>dashed line between constraints &#8211; represents a non-crucial ranking</li>
<li>I&#8217;m not going to make this distinction in any tableaux, but you should be aware of the difference. (We&#8217;ll dicuss why dashed vs. solid lines is an unhelpful and insufficient distinction on the next handout.)</li>
</ul></li>
<li>Below is a tableau with shading and exclamation marks added.

<ul>
<li>exclamation marks &#8211; suffixed to the asterisk that &#8220;kills&#8221; a candidate (the <strong>fatal violation</strong>)</li>
<li>shading &#8211; shows that a cell is not relevant, either because the winner has already been chosen, or because that candidate has already been ruled out.

<ul>
<li>All cells to the right of an exclamation mark are shaded.</li>
<li>Cells in the winner&#8217;s row may also be shaded, if the corresponding constraints were not consulted by EVAL.</li>
<li>A constraint whose column is shaded is <strong>inactive</strong> in the candidate selection process.</li>
</ul></li>
<li>The pointing finger, exclamation marks, and shading are predictable from the asterisks, but they are helpful to the reader.</li>
</ul></li>
</ul>

<table class="tableau">
<caption style="caption-side: bottom;" id="exampleofatableau">Example of a tableau with shading and exclamation marks</caption>
<colgroup>
<col />
<col style="text-align:left;"/>
<col style="text-align:right;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
    <th colspan="3">Candidates  </th>
    <th style="text-align:center;">    <em>*CC</em> </th>
    <th style="text-align:center;"><em>Dep&#8211;V</em> </th>
</tr>
</thead>

<tbody>
<tr>
    <td>/at-ka/ </td>
    <td style="text-align:left;">a. </td>
    <td style="text-align:right;">☞ [atəka]  </td>
    <td style="text-align:center;">  </td>
    <td class="shaded2", style="text-align:center;"> ✳︎  </td>
</tr>
<tr>
    <td>   </td>
    <td style="text-align:left;">b. </td>
    <td style="text-align:right;">[atka]   </td>
    <td style="text-align:center;">✳︎!  </td>
    <td class = "shaded2", style="text-align:center;">  </td>
</tr>
</tbody>
</table>

<ul>
<li>We can show multiple inputs in the same tableau, since all inputs in a language are subject to the same ranking of constraints.</li>
</ul>

<div class="tableau">
<table>
<caption style="caption-side: bottom;" id="exampleofaviolationtableau">Example of a tableau with multiple inputs</caption>
<colgroup>
<col />
<col style="text-align:left;"/>
<col style="text-align:right;"/>
<col style="text-align:center;"/>
<col style="text-align:center;"/>
</colgroup>

<thead>
<tr>
    <th colspan="3">Candidates  </th>
    <th style="text-align:center;">    <em>*CC</em> </th>
    <th style="text-align:center;"><em>Dep&#8211;V</em> </th>
</tr>
</thead>

<tbody>
<tr>
    <td>/at-ka/ </td>
    <td style="text-align:left;">a. </td>
    <td style="text-align:right;">☞ [atəka]  </td>
    <td style="text-align:center;">  </td>
    <td class="shaded2"; style="text-align:center;"> ✳︎  </td>
</tr>
<tr>
    <td>   </td>
    <td style="text-align:left;">b. </td>
    <td style="text-align:right;">[atka]   </td>
    <td style="text-align:center;">✳︎!  </td>
    <td class="shaded2"; style="text-align:center;">  </td>
</tr>
</tbody>

<tbody>
<tr>
    <td>/at-a/ </td>
    <td style="text-align:left;">a. </td>
    <td style="text-align:right;">[atəa]   </td>
    <td style="text-align:center;">  </td>
    <td style="text-align:center;"> ✳︎! </td>
</tr>
<tr>
    <td>   </td>
    <td style="text-align:left;">b. </td>
    <td style="text-align:right;">☞ [ata]   </td>
    <td style="text-align:center;">  </td>
    <td style="text-align:center;">  </td>
</tr>
</tbody>
</table>
</div>

<h1 id="practicetableau">Practice tableau</h1>

<ul>
<li>Let&#8217;s make a tableau for the Dutch example from the last handout.</li>
<li>Recall the problem:

<ul>
<li>Dutch inserts ʔ to avoid two adjacent vowels.</li>
<li>But ʔ is only permitted before a stressed vowel.</li>
</ul></li>
<li>Constraints for the tableau (poorly defined):

<ul>
<li><span style="font-variant:small-caps;">Max-V</span>: don&#8217;t delete a vowel.</li>
<li><span style="font-variant:small-caps;">Ident</span>(stress): don&#8217;t change a segment&#8217;s value for the feature [stress].</li>
<li>*VV: avoid two vowels in a row.</li>
<li><span style="font-variant:small-caps;">Dep-C</span>: don&#8217;t insert a consonant.</li>
<li>*ʔV: don&#8217;t have a glottal stop before an unstressed vowel.</li>
</ul></li>
<li>Mappings:

<ul>
<li>/aɔ́rta/ → [aʔɔ́rta]</li>
<li>/xáɔs/ → [xáɔs]</li>
</ul></li>
<li>Redefine these constraints so they aren&#8217;t ambiguous, make tableaux for both inputs, and find a ranking that works.

<ul>
<li>Once we have better definitions for constraiants, let&#8217;s come up with a preliminary candidate set together.</li>
<li>The best approach for ranking constraints is to put the constraints into a tableau in a random order and then reason from there about the ranking.</li>
</ul></li>
</ul>

<h1 id="recapofmajorideas">Recap of major ideas</h1>

<ul>
<li>Assumptions of OT

<ul>
<li>a ranking of constraints

<ul>
<li>strict domination</li>
<li>the ≫ symbol</li>
<li>the same ranking is used for all inputs in a language</li>
</ul></li>
<li>constraints are violable</li>
<li>very important idea: <em>all</em> systematic phonological patterns in a language come from the same constraint ranking

<ul>
<li>alternations</li>
<li>phonotactics</li>
<li>segmental inventory</li>
</ul></li>
<li>very important idea: <em>all</em> systematic differences between languages come from differences in constraint ranking

<ul>
<li>factorial typology</li>
<li>rankings are language-particular</li>
<li>GEN, CON, EVAL are universal</li>
<li>Richness of the Base</li>
</ul></li>
</ul></li>
<li>GEN

<ul>
<li>Freedom of Analysis</li>
<li>the faithful candidate</li>
</ul></li>
<li>CON

<ul>
<li>constraints as violation-counting functions</li>
<li>markedness</li>
<li>faithfulness</li>
<li>no constraints on the structure of URs</li>
</ul></li>
<li>EVAL

<ul>
<li>as a slogan: &#8220;take the best, ignore the rest&#8221;</li>
<li>the strictness of strict domination</li>
</ul></li>
<li>The OT tableau

<ul>
<li>ranking argument</li>
<li>crucial ranking</li>
<li>violation marks</li>
<li>the pointing finger</li>
<li>exclamation marks</li>
<li>shading</li>
<li>don&#8217;t bother with solid vs. dashed lines</li>
</ul></li>
</ul>

<div class="footnotes">
<hr />
<ol>

<li id="fn:1">
<p>I&#8217;ve lifted &#8220;take the best, ignore the rest&#8221; from the Take-The-Best decision-making algorithm of Gigenrezer and Goldstein (1996), which uses strictly ranked cues to make binary decisions. The decisions they&#8217;re interested in aren&#8217;t phonological, e.g. &#8220;Which of these two cities has a higher population?&#8221;, and the cues are things like &#8220;Does this city have a soccer team?&#8221; However, the mechanisms are very similar to OT. From the first lines of the paper&#8217;s abstract: &#8220;Humans and animals make inferences about the world under limited time and knowledge. In contrast, many models of rational inference treat the mind as a Laplacean Demon, equipped with unlimited time, knowledge, and computational might. Following H. Simon&#8217;s notion of satisficing, the authors have proposed a family of algorithms based on a simple psychological mechanism: one-reason decision making.&#8221; <a href="#fnref:1" title="return to body" class="reversefootnote">&#160;&#8617;</a></p>
</li>

</ol>
</div>

</body>
</html>

